Вот у нас есть такой кусок кода, в котором мы запускаем 50 горутин одновременно, и каждая пытается
выполнить `GetConnectionOnce()`

```go
func main() {
	var wg sync.WaitGroup

	ConnectionPool := pg.PostgresNewPool()
	for i := 0; i < 50; i++ {
		wg.Go(func() {
			start := time.Now()
			conn := ConnectionPool.GetConnectionOnce()
			fmt.Printf("Горутина %d получила подключение %d за %v\n", i, conn.ID, time.Since(start))
		})
	}
}
```

Внутри `GetConnectionOnce` есть задержка в 50ms.
    
```go
func (pg *PostgresSQLConnPool) GetConnectionOnce() *Connection {
	pg.once.Do(func() {
		fmt.Println("Подключение инициализировано")
		time.Sleep(50 * time.Millisecond) // Задержка на подключение
		pg.conn = &Connection{ID: rand.Intn(1000)}
	})
	return pg.conn
}
```
По идее, если эта функция выполняется только один раз, ее может выполнить только одна горутина.

Почему тогда задержку в 50 ms показывают все горутины?

```bash
| Горутина | ID подключения | Время получения |
|----------|----------------|----------------|
| 2        | 857            | 50.4196ms      |
| 6        | 857            | 50.4196ms      |
| 4        | 857            | 50.4196ms      |
| 5        | 857            | 50.4196ms      |
| 9        | 857            | 50.4196ms      |
| 7        | 857            | 50.4196ms      |
| 0        | 857            | 50.4196ms      |
| 8        | 857            | 50.4196ms      |
| 11       | 857            | 50.4196ms      |
| 10       | 857            | 50.4196ms      |
| 12       | 857            | 50.4196ms      |
| 3        | 857            | 50.4196ms      |
| 13       | 857            | 50.6283ms      |
| 17       | 857            | 50.6283ms      |
| 14       | 857            | 50.6283ms      |
| 15       | 857            | 50.6283ms      |
```
GPT мне рассказала, что несмотря на то, что функция внутри `once.Do()` выполняяется только
один раз, остальные горутины также заходят в `once.Do()`, видят, что инициализация начата другой
горутиной и блокируются. После этого они ждут, пока первая горутина закончится.

Соответственно они сами не выполняют `time.sleep()`, но поскольку ждут в очереди, то замеряют общее
время выполнения, поэтому задержка выводится у всех.

Хотел спросить, насколько она права, и есть ли вариант сделать так, чтобы если `once.DO()` выполняется в нескольких горутинах, то те, которые не получили доступ, могли бы не ждать конца?

А то мы вроде бы выполняем функцию один раз, а по факту блокируем все горутины. Может быть существует 
более оптимальный способ использования `once.Do()` в подобных сценариях?

Проверил кстати сценарий если мы без горутин просто 50 раз выполним цикл
```go
	ConnectionPool2 := pg.PostgresNewPool()

	for i := 0; i < 50; i++ {
		start := time.Now()
		conn := ConnectionPool2.GetConnectionOnce()
		fmt.Printf("Цикл %d получил подключение %d за %v\n", i, conn.ID, time.Since(start))
	}
```

```bash
| i  | ID подключения | Время получения |
| -- | -------------- | --------------- |
| 0  | 244            | 50.6411ms       |
| 1  | 244            | 0               |
| 2  | 244            | 0               |
| 3  | 244            | 0               |
| 4  | 244            | 0               |
| 5  | 244            | 0               |
| 6  | 244            | 0               |
| 7  | 244            | 0               |
| 8  | 244            | 0               |
| 9  | 244            | 0               |
| 10 | 244            | 0               |
| 11 | 244            | 0               |
| 12 | 244            | 0               |
| 13 | 244            | 0               |
| 14 | 244            | 0               |
| 15 | 244            | 0               |
```
Таким образом получается, что как-будто бы sync.Once не стоит использовать в горутинах

Также попробовал добиться аналогично поведения через sync.Cond, вроде получилось.
```go
func (pg *PostgresSQLConnPoolSC) GetConnectionSC() *ConnectionSC {
	pg.cond.L.Lock()
	defer pg.cond.L.Unlock()

	if pg.conn == nil {
		time.Sleep(50 * time.Millisecond)
		pg.conn = &ConnectionSC{ID: rand.Intn(1000)}
	}
	return pg.conn
}

```
Интересный вывод дает `GetConenction` без `sync.Once()`


| Горутина | ID подключения | Время получения |
| -------- | -------------- | --------------- |
| 7        | 877            | 50.6039ms       |
| 16       | 657            | 50.6039ms       |
| 15       | 657            | 50.6039ms       |
| 4        | 657            | 50.6039ms       |
| 14       | 735            | 50.6039ms       |
| 21       | 657            | 50.12ms         |
| 41       | 769            | 50.1661ms       |
| 36       | 468            | 50.1661ms       |
| 30       | 403            | 50.1661ms       |

Тут видно что соединение пересоздается каждый раз. 
А еще видно что у некоторых горутин соедение одно и то же. Это как я понимаю data race.